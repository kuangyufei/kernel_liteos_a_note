[鸿蒙内核源码注释中文版 【 Gitee仓 ](https://gitee.com/weharmony/kernel_liteos_a_note)|[ CSDN仓 ](https://codechina.csdn.net/kuangyufei/kernel_liteos_a_note)|[ Github仓 ](https://github.com/kuangyufei/kernel_liteos_a_note)|[ Coding仓 】](https://weharmony.coding.net/public/harmony/kernel_liteos_a_note/git/files)精读内核源码,中文详细注解.深挖地基工程,构建底层网图.

[鸿蒙源码分析系列篇 【 CSDN ](https://blog.csdn.net/kuangyufei/article/details/108727970)[| OSCHINA ](https://my.oschina.net/u/3751245/blog/4626852)[| HarmonyOS 】](https://weharmony.github.io/)问答式导读, 生活式比喻, 图形化展示, 层层剥开内核神秘外衣.

---

先看四个宏定义，进程和线程（线程就是任务）最高和最低优先级定义，\[0,31\]区间，即32级，优先级用于调度，CPU根据这个来决定先运行哪个进程和任务。

```cpp
#define OS_PROCESS_PRIORITY_HIGHEST      0	//进程最高优先级
#define OS_PROCESS_PRIORITY_LOWEST       31 //进程最低优先级
#define OS_TASK_PRIORITY_HIGHEST    0	//任务最高优先级,软时钟任务就是最高级任务,见于 OsSwtmrTaskCreate
#define OS_TASK_PRIORITY_LOWEST     31 //任务最低优先级
```

## 为何进程和线程都是32个优先级？

回答这个问题之前，先回答另一个问题，为什么人类几乎所有的文明都是用十进制的计数方式。答案掰手指就知道了，因为人有十根手指头。玛雅人的二十进制那是把脚指头算上了，但其实也算是十进制的表示。

这是否说明一个问题，认知受环境的影响，方向是怎么简单/方便怎么来。这也可以解释为什么人类语言发音包括各种方言对妈妈这个词都很类似，因为婴儿说mama是最容易的。 注意认识这点很重要！

而计算机的世界是二进制的，是是非非，清清楚楚，特别的简单，二进制已经最简单了，到底啦，不可能有更简单的了。还记得双向链表篇中说过的吗，因为简单所以才不简单啊，大道若简，计算机就靠着这01码，表述万千世界。

但人类的大脑不擅长存储，二进制太长了数到100就撑爆了大脑，记不住，为了记忆和运算方便，编程常用靠近10进制的 16进制来表示 ,0x9527ABCD 看着比 0011000111100101010100111舒服多了。

## 应用开发和内核开发有哪些区别？

区别还是很大的，这里只说一点，就是对位的控制能力，内核会出现大量的按位运算(&，|，~，^) , 一个变量的不同位表达不同的含义，但这在应用程序员那是很少看到的，他们用的更多的是逻辑运算（&&，||，！）

```cpp
#define OS_TASK_STATUS_INIT         0x0001U //初始化状态
#define OS_TASK_STATUS_READY        0x0002U //就绪状态的任务都将插入就绪队列
#define OS_TASK_STATUS_RUNNING      0x0004U //运行状态
#define OS_TASK_STATUS_SUSPEND      0x0008U //挂起状态
#define OS_TASK_STATUS_PEND         0x0010U //阻塞状态
```

这是任务各种状态（注者后续将比如成贴标签）表述，将它们还原成二进制就是：

0000000000000001 = 0x0001U

0000000000000010 = 0x0002U

0000000000000100 = 0x0004U

0000000000001000 = 0x0008U

0000000000010000 = 0x0010U

发现二进制这边的区别没有，用每一位来表示一种不同的状态，1表示是，0表示不是。

这样的好处有两点：

1.可以多种标签同时存在 比如 0x07 = 0b00000111,对应以上就是任务有三个标签（初始，就绪，和运行），进程和线程在运行期间是允许多种标签同时存在的。

2.节省了空间，一个变量就搞定了，如果是应用程序员要实现这三个标签同时存在，习惯上要定义三个变量的，因为你的排他性颗粒度是一个变量而不是一个位。

而对位的管理/运算就需要有个专门的管理器：位图管理器 (见源码 los_bitmap.c )

## 什么是位图管理器？

直接上部分代码，代码关键地方都加了中文注释，简单说就是对位的各种操作，比如如何在某个位上设1?如何找到最高位为1的是哪个位置?这些函数都是有大用途的。

```cpp
//对状态字的某一标志位进行置1操作
VOID LOS_BitmapSet(UINT32 *bitmap, UINT16 pos)
{
    if (bitmap == NULL) {
        return;
    }

    *bitmap |= 1U << (pos & OS_BITMAP_MASK);//在对应位上置1
}
//对状态字的某一标志位进行清0操作
VOID LOS_BitmapClr(UINT32 *bitmap, UINT16 pos)
{
    if (bitmap == NULL) {
        return;
    }

    *bitmap &= ~(1U << (pos & OS_BITMAP_MASK));//在对应位上置0
}
/********************************************************
杂项算术指令
CLZ 用于计算操作数最高端0的个数，这条指令主要用于一下两个场合
　　计算操作数规范化（使其最高位为1）时需要左移的位数
　　确定一个优先级掩码中最高优先级
********************************************************/
//获取状态字中为1的最高位 例如: 00110110 返回 5
UINT16 LOS_HighBitGet(UINT32 bitmap)
{
    if (bitmap == 0) {
        return LOS_INVALID_BIT_INDEX;
    }

    return (OS_BITMAP_MASK - CLZ(bitmap));
}
//获取状态字中为1的最低位， 例如: 00110110 返回 2
UINT16 LOS_LowBitGet(UINT32 bitmap)
{
    if (bitmap == 0) {
        return LOS_INVALID_BIT_INDEX;
    }

    return CTZ(bitmap);//
}


```

## 位图在哪些地方应用？

内核很多模块在使用位图，这里只说进程和线程模块，还记得开始的问题吗，为何进程和线程都是32个优先级？因为他们的优先级是由位图管理的，管理一个UINT32的变量，所以是32级，一个位一个级别，最高位优先级最低。

```cpp
    UINT32          priBitMap;          /**< BitMap for recording the change of task priority,	//任务在执行过程中优先级会经常变化，这个变量用来记录所有曾经变化
                                             the priority can not be greater than 31 */			//过的优先级，例如 ..01001011 曾经有过 0,1,3,6 优先级


```

这是任务控制块中对调度优先级位图的定义，注意一个任务的优先级在运行过程中可不是一成不变的，内核会根据运行情况而改变它的，这个变量是用来保存这个任务曾经有过的所有优先级历史记录。

比如 任务A的优先级位图是 00000001001011 ，可以看出它曾经有过四个调度等级记录，那如果想知道优先级最低的记录是多少时怎么办呢？

诶,上面的位图管理器函数 UINT16 LOS_HighBitGet(UINT32 bitmap) 就很有用啦 ，它返回的是1在高位出现的位置，可以数一下是 6

因为任务的优先级0最大，所以最终的意思就是A任务曾经有过的最低优先级是6

一定要理解位图的操作，内核中大量存在这类代码，尤其到了汇编层，对寄存器的操作大量的出现。

比如以下这段汇编代码。

```cpp
    MSR     CPSR_c, #(CPSR_INT_DISABLE | CPSR_SVC_MODE)  @禁止中断并切到管理模式
    LDRH    R1, [R0, #4] 	@将存储器地址为R0+4 的低16位数据读入寄存器R1，并将R1的高16 位清零
    ORR     R1, #OS_TASK_STATUS_RUNNING @或指令 R1=R1|OS_TASK_STATUS_RUNNING
    STRH    R1, [R0, #4] 	@将寄存器R1中的低16位写入以R0+4为地址的存储器中


```
### **喜欢就关注下吧,您的关注真的很重要**

![在这里插入图片描述](https://gitee.com/weharmony/kernel_liteos_a_note/raw/master/zzz/pic/other/wxcode.png)

作者邮箱:weharmony@126.com

---

[![WeHarmony/kernel_liteos_a_note](https://gitee.com/weharmony/kernel_liteos_a_note/widgets/widget_card.svg?colors=4183c4,ffffff,ffffff,e3e9ed,666666,9b9b9b)](https://gitee.com/weharmony/kernel_liteos_a_note)

[鸿蒙内核源码注释中文版 【 Gitee仓 ](https://gitee.com/weharmony/kernel_liteos_a_note)|[ CSDN仓 ](https://codechina.csdn.net/kuangyufei/kernel_liteos_a_note)|[ Github仓 ](https://github.com/kuangyufei/kernel_liteos_a_note)|[ Coding仓 】](https://weharmony.coding.net/public/harmony/kernel_liteos_a_note/git/files)精读内核源码,中文详细注解.深挖地基工程,构建底层网图.

[鸿蒙源码分析系列篇 【 CSDN ](https://blog.csdn.net/kuangyufei/article/details/108727970)[| OSCHINA ](https://my.oschina.net/u/3751245/blog/4626852)[| HarmonyOS 】](https://weharmony.github.io/)问答式导读, 生活式比喻, 图形化展示, 层层剥开内核神秘外衣.